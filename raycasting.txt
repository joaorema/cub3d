Horizontal Ray Casting (
horizontal_check
): The horizontal check is implemented in 
horizontal_check
. It works as follows:
For each ray, it calculates the next intersection with a horizontal wall line:
Uses atan_angle = -1 / tan(ray_angle) for the slope
Depending on the angle:
If ray_angle == 0 or PI: Uses 
h_sides
 (special case for horizontal walls)
If ray_angle > PI: Uses 
h_up
 (ray pointing upwards)
If ray_angle < PI: Uses 
h_down
 (ray pointing downwards)
Vertical Ray Casting (
vertical_check
): The vertical check is implemented in 
vertical_check
. It works as follows:
For each ray, it calculates the next intersection with a vertical wall line:
Uses ntan_angle = -tan(ray_angle) for the slope
Depending on the angle:
If ray_angle == P2 or P3 (90° or 270°): Uses 
v_top_down
 (special case for vertical walls)
If ray_angle < P2 or > P3: Uses 
v_right
 (ray pointing right)
If ray_angle > P2 and < P3: Uses 
v_left
 (ray pointing left)
Ray Casting Process: The main ray casting process in 
render_rays
 works as follows:
For each ray (NUM_RAYS total):
Calculate the ray angle based on player's angle and FOV
Perform both horizontal and vertical checks
Compare distances to find the closest wall hit
Project the wall slice based on distance and angle
Wall Hit Calculation: When a hit is found (either horizontal or vertical):
The hit position is stored in hit->hit_pos
Distance is calculated using the distance formula:
c
distance = sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay))
The closest hit (between horizontal and vertical) is chosen:
c
if (vhit->distance < hhit->distance) {
    wall->distance = vhit->distance;
    wall->hit_vertical = 1;
    wall->hit_point = vhit->hit_pos;
}
Wall Rendering: Once a wall hit is found:
The wall height is calculated based on distance
The correct texture is chosen based on which side was hit (NORTH, SOUTH, EAST, WEST)
The wall slice is drawn with the appropriate texture
This implementation uses a DDA (Digital Differential Analyzer) approach for both horizontal and vertical ray casting, which is efficient for grid-based maps. The raycaster calculates both horizontal and vertical intersections and chooses the closest one to ensure accurate wall detection.

The project also includes optimizations like:

Early termination when a wall is found within max depth
Distance correction for fisheye effect
Texture mapping based on hit position
Proper wall height calculation based on distance
This implementation is typical of a Wolfenstein 3D-style raycaster, where rays are cast from the player's position to create the 3D view of the world.
